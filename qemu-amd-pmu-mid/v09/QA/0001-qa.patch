diff --git a/target/i386/kvm/kvm.c b/target/i386/kvm/kvm.c
index 67adfafa0c..171f7eae67 100644
--- a/target/i386/kvm/kvm.c
+++ b/target/i386/kvm/kvm.c
@@ -2068,6 +2068,12 @@ int kvm_arch_pre_create_vcpu(CPUState *cpu, Error **errp)
     if (first) {
         first = false;
 
+        if (X86_CPU(cpu)->enable_pmu) {
+            printf("pmu is enabled\n");
+        } else {
+            printf("pmu is disabled\n");
+        }
+
         /*
          * Since Linux v5.18, KVM provides a VM-level capability to easily
          * disable PMUs; however, QEMU has been providing PMU property per
@@ -2176,6 +2182,8 @@ static bool is_host_compat_vendor(CPUX86State *env)
 
     host_cpu_vendor_fms(host_vendor, NULL, NULL, NULL);
 
+    printf("host_vendor=%s\n", host_vendor);
+
     /*
      * Intel and Zhaoxin are compatible.
      */
@@ -2183,6 +2191,7 @@ static bool is_host_compat_vendor(CPUX86State *env)
          g_str_equal(host_vendor, CPUID_VENDOR_ZHAOXIN1) ||
          g_str_equal(host_vendor, CPUID_VENDOR_ZHAOXIN2)) &&
         (IS_INTEL_CPU(env) || IS_ZHAOXIN_CPU(env))) {
+        printf("vendor compatible!\n");
         return true;
     }
 
@@ -2413,6 +2422,8 @@ int kvm_arch_init_vcpu(CPUState *cs)
     cpuid_data.cpuid.nent = cpuid_i;
 
     kvm_init_pmu_info(&cpuid_data.cpuid, cpu);
+    printf("pmu_cap=%d\n", pmu_cap);
+    printf("version=%u, pmc=%u, fixed=%u\n", pmu_version, num_pmu_gp_counters, num_pmu_fixed_counters);
 
     if (x86_cpu_family(env->cpuid_version) >= 6
         && (env->features[FEAT_1_EDX] & (CPUID_MCE | CPUID_MCA)) ==
@@ -4188,6 +4199,7 @@ static int kvm_put_msrs(X86CPU *cpu, KvmPutState level)
         }
 
         if ((IS_INTEL_CPU(env) || IS_ZHAOXIN_CPU(env)) && pmu_version > 0) {
+            printf("kvm_put_msrs() reset Intel or Zhaoxin\n");
             if (pmu_version > 1) {
                 /* Stop the counter.  */
                 kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);
@@ -4229,6 +4241,8 @@ static int kvm_put_msrs(X86CPU *cpu, KvmPutState level)
              */
             uint32_t step = 1;
 
+            printf("kvm_put_msrs() reset AMD\n");
+
             /*
              * When PERFCORE or PerfMonV2 is enabled, AMD PMU uses a
              * separate set of addresses for the selector and counter
@@ -4766,6 +4780,7 @@ static int kvm_get_msrs(X86CPU *cpu)
     }
 
     if ((IS_INTEL_CPU(env) || IS_ZHAOXIN_CPU(env)) && pmu_version > 0) {
+        printf("kvm_get_msrs() reset Intel or Zhaoxin\n");
         if (pmu_version > 1) {
             kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0);
             kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0);
@@ -4791,6 +4806,8 @@ static int kvm_get_msrs(X86CPU *cpu)
          */
         uint32_t step = 1;
 
+        printf("kvm_get_msrs() reset AMD\n");
+
         /*
          * When PERFCORE or PerfMonV2 is enabled, AMD PMU uses a separate
          * set of addresses for the selector and counter registers.
-- 
2.39.3

